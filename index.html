<!DOCTYPE html>
<html lang="en">
<head>
  <title>thoughts</title>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <meta charset="UTF-8">
  <meta name="author" content="Chris Smith">
  <meta name="description" content="thoughts, programming, ruby, python, c, java">
  <meta name="keywords" content="thoughts, programming, ruby, python, c, java">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap-theme.min.css">
  <script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
</head>

<body style="margin-top:30px; padding-top:70px;">

<nav class="navbar navbar-default navbar-fixed-top navbar-inverse">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/"><span class="glyphicon glyphicon-home" aria-hidden="true"></span> chris smith</a>
    </div>
    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="https://www.youtube.com/user/cleesmith2006/videos" target="_blank">videos</a></li>
        <li><a href="https://github.com/cleesmith?tab=repositories" target="_blank">projects</a></li>
        <li><a href="about.html">about</a></li>
      </ul>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

<div class="container">

<pre>
If I wanted to make Cellipede a web app there are many options available, for example:
<a href="http://beego.me/docs/intro/" target="_blank">beego</a> if one wanted to continue in the cookie cutter rut that is Python/Flask or Ruby/Rails
See <a href="https://github.com/avelino/awesome-go" target="_blank">awesome-go</a> for a curated list of Go frameworks, libraries and software.
However, I just don't see gathering social metrics and page scraping as a web app, but more of a command line
program that dumps the gathered data to a csv/xls file, google drive, or whatever.
But there's definitely concurrency as counts and scraped data are from different sources
and can be gathered in parallel ... this is so obvious as to be stupid not to do it that way,
why waste 10 seconds when the whole thing can be done in 3 seconds (or whatever the longest took).

Of course, for my day job I'm stuck with C++, Ruby/Rails, and some Python programs.
I could switch the Python programs to Go, which I will do as my employer is cool with that.
I could switch the C++ programs to Go, but there's really no compelling reason to do so ... as
they are already statically linked, easy to install, and blazingly fast.
However, because Ruby/Rails is so familiar and simple -- well, until you have to scale it -- I'm
stuck with it for the foreseeable future. But hey the pay is great plus Ruby is a thing of
beauty to read/write when the opportunity arises to get off the "rails". While python can
be written in a OOP way like ruby, that does not seem to be the common approach. It's like
python is the "Joe lunch pail" of programming languages, because those who can't think and
reason about a problem look for a package/library of which there are many. But "many" does
not equal worthy of being used. So that leaves a pythonista with just writing a tiny bit of
"glue code" (similar to PHP), and spending the rest of their time wrestling with deployment.
By deployment I mean trying to get easy_install, or pip, or C libraries to all match up and
work as expected. It's that headache that led to containers (like Docker) and Chefs and Puppets - wtf?
How about that, Docker is written in Go. Notice that at no time and in no way do I refer to
Javascript, which unfortunately is just a necessary evil on the front end of all web apps ...
so it will remain the "king of all programming languages" and the ultimate atlatl. So why
not give in to the dark side that is javascript and use node.js? A good question. Well,
fortunately, programming is like life with lots of diversity and choices. So do what you
enjoy and get down off of your soap box. I will always love ruby (cha-ching$) and appreciate
the knowledge that c/c++ has provided me, but now like all of the other languages tried
before I will give Go more than a cursory glance ... because I can afford to, I enjoy coding,
and it's a good thing to stretch one's mind (even if the underlying problems are still the same).
I don't sit around all day googling/reading blog posts and then pretend I have an informed
opinion based on "real" experience. Nor do I try every programming language that comes out the pipe.
It's been a while, but I even wrote two languages myself. I sure hope no one discovers them
or worse that someone is using them. One was like Pascal and the other was like Forth. I always
liked Forth, how can you not like a language that can create programs that alter their machine code
while it is executing ... cool and stupid at the same time ... for some reason that reminds
me of core war in 1984 and my old Super Elf (those were the days, ah, the smell of solder ... or
better said "hot molten lead").
Here's a <a href="http://www.digibarn.com/collections/systems/quest-cosmac-super-elf/index.html" target="_blank">Super Elf</a> but mine was in a wood case ... what's that guy thinking? is a computer without the wood? wtf?
</pre>

<pre>
The concurrency offered by Go makes it a perfect choice for Cellipede:
- as many of the tasks don't need to be done sequentially
- all of the social metrics gathering can be done concurrently
- instead of waiting 5-15 seconds for all of the api's or scrape's to respond, they
  can be done concurrently which means the total time is equal to the longest task
  and not all of them added together ... i.e. way faster

Of course, the greatest advantage of using Go is compiling a single binary file for a target system.
No more dependency hell ... just scp/rsync/whatever the file to the target and run it.

And compiling for any/all target systems, including ARM (Raspberry Pi, etc.), is simple using
the Go installed by Homebrew ... i.e. do everything on a Mac, just once, but deploy anywhere -- way cool.

If all of us are putting all of our eggs in Google's basket, g+/gmail/calendar/docs/maps/etc, what
better programming language choice than the one funded/used internally by Google ... Go_ogle it is.

Of course, absolutely none of the above is new (see Hoare 1978) ... think C/C++ ... but Go is
just a better and simpler packaging of what's been learned over the years.

There's no one solution, well, until the day arrives when computers can solve problems all
by themselves (without humans). Sure, it will happen, but by that time they will be
called "focused thinkers"(FTs) or some such and the idea of "computing" will be long dead.
Why the term "focused thinkers"(FTs)?  Because humans suck at focusing, we're easily distracted,
whereas FTs' will have laser focus on the task at hand (so to speak).
We will be partners, FTs and humans, and hopefully the FTs will not smash us the way we probably
did the Neanderthals. Imagine two football teams made up of Neanderthals, e.g. the Unibrows vs Rockheads,
on surround sound TV and all of the concussions/injuries ... I'm sure the Romans would have filled the
coliseum with them.  My guess is that we used our atlatl's to kill them or bred them out ... brain power rules.
Go is so simple even a Neanderthal can do it, or could if they were still around.
Go is just another in a long list of atlatls, i.e. a tool we use to help us with stuff.
What we really need is the next evolutionary step above tooling, such as a focused thinker and
who knows what form that may take ... it does not have to be a machine. Perhaps we change or evolve
into focused thinkers, and inevitably smash the current us, of course.

This universe is a funny ole dog.

... obliquely related joke:
How is a Harley Davidson like an old dog?
They both like to ride in the back of pickup trucks.

What is the difference between a Harley Davidson and an old dog?
The dog can get in the back of the pickup by itself.

I don't own or know how to ride a motocycle or know anyone who does, so why does this joke stick in my head?
Further evidence of how unfocused humans can be ... we've had our time in the sun and it's time to evolve, yet again.
</pre>

<pre>
just discovered <a href="https://golang.org/" target="_blank">Go</a> (GoLang):
- it's fast when compiling and the result is fast at execution time
- it's cool, coz "go build" creates a statically linked program
- a "statically linked program" is cool coz it can just be copied around without an install or dependencies ...
  it just needs to be a binary file that's built for that operating system (linux, mac, windows)
- a program can be compiled on a Mac for all operating systems ... i.e. cross compiling
- installation of a program becomes just copying the binary file to the target system
- a small <a href="http://beego.me/" target="_blank">Beego</a> (like flask/rails) web app is about 20MB binary file, that's small
- there's no installing an interpreter (Python or Ruby), or packages/dependencies (pip or gems) ...
  the only real dependency is the target system
- the downside is that the Go language is not as eloquent as Ruby, but it's faster/smaller and without the
  usual difficult and error prone installation process

Python is great for beginners and playing around.

Ruby is great for learning object oriented programming, teams, and cookie cutter web apps with Rails.

Go is the way forward ... with:
  - great docs
  - everything that's provided by Ruby/Python but with a different syntax
  - contains a fully functional web server, but can also be proxied via nginx (which is much faster for static assets)
  - multi-core support baked in
  - concurrency built-in
  - high performance is in large part due to the static compilation of the statically-typed code (not quite as fast as C, but close)
  - no install on target system due to static linking, just copy binary file to target then "./someprogram"
</pre>

<pre>
an open source alternative to <a href="https://slack.com" target="_blank">Slack</a>:
<a href="http://www.mattermost.org/" target="_blank">Mattermost</a> at <a href="https://github.com/mattermost/platform" target="_blank">github</a>
- Mattermost is coded in Go (a better C?) and available as a Docker image
- Slack is coded in PHP (yuck!), MySQL (yuck!), and uses SOLR (yuck!) for indexing/searching
- Mattermost has fewer features than Slack
- Mattermost can be hosted locally if security matters or if you don't want to pay a service fee
- there are other Slack-like projects, but Mattermost is not just another pile of open source code as they are also building a community
- Slack is better if you don't have enterprise/security concerns and don't mind paying for the service
</pre>

<pre>
new software:
<a href="https://github.com/cleesmith/cellipede_ruby" target="_blank">cellipede_ruby</a> which is a search engine optimization, SEO, command line tool for data gathering that creates Excel spreadsheets
</pre>

<pre>
the beauty of Ruby and what few people understand ... simplified:
- <b>1.class</b> means <b>1</b> is an <b>object</b> whose <b>class</b> is Fixnum
- <b>Fixnum.instance_methods(false)</b> reveals this object to have these methods [:to_s, :+, :-, :==, etc], so
- <b>1.to_s</b> is really 1.send(:to_s) and <b>1 + 1</b> is really 1.send(:+, 1)
- yes, <b>send</b> is just passing a <b>message</b> to an <b>object</b>
- of course, I don't need to know about <em>sending messages to objects</em> just to do <b>1 + 1</b>

Ruby is an absolute beauty and why I say it's <b>manna from heaven</b>, ok, Japan actually.
Of course, it may be more beautiful to have a language like Smalltalk with only 6 keywords and no conditionals ... true OO
</pre>

<pre>
always apply these ideas from Sandi Metz:
 <b>be Smalltalk infected</b>
 <b>be Condition averse</b> ... when possible avoid if/else/case/unless ... keep the <em>happy path</em> visible and readable
 <b>be Message centric</b>
    - don't own the behavoir of an object
    - null object pattern
    - composition ... beware of always using inheritance, it's not for sharing behavoir
    - independency injection for behavior
 <b>be Abstraction seeking</b>
* see: <a href="https://www.youtube.com/watch?v=OMPfEXIlTVE" target="_blank">Sandi Metz</a> and her <a href="http://www.amazon.com/Practical-Object-Oriented-Design-Ruby-Addison-Wesley-ebook/dp/B0096BYG7C/ref=tmm_kin_title_0?_encoding=UTF8&sr=8-1&qid=1434722417" target="_blank">book</a> is great too
For the most part, my projects accomplish each of the <b>be</b>'s above.
</pre>

<pre>
If you have a project that you consider to be <b>intellectual property</b> ... that's great, you're brilliant,
but keep it to yourself, try a private repo, until you're ready to <b>gift your little wonder</b> to the world

But open source is not <b>intellectual property</b>, and best explained by Remy Sharp:
"<em>
 Welcome. Welcome to this code I wrote.
 Help yourself to bits you like or need.
 Help make it better for others.
 Help make it yours.
 Help make me better with your suggestions, changes or discussion.
 Use the code in any way you want, in ways I never thought of.
 And if the projects I created lives on without me, then open source has worked.
"</em>
If you don't understand the above then you just don't understand github or open source software.
</pre>

<pre>
learn Clojure and Elixir

return to Smalltalk more often

Rails, given the <b>monkey-patched mess</b> it's become, will be the ruin of Ruby
... bummer, as I used Ruby before Rails came along, and, often, it will put a <b>smile on your face</b>

Python ... well, why, if you have Ruby? ... well, ok, maybe for nltk, pandas, scipy, scikit-learn, matplotlib, and numpy.
Sometimes you may want to <b>wax nostalgic</b> and relive the days of gigantic loops, with lots of sideways pyramid-style indented code,
and if-else's the size of Montana (you know, big) ... just to remind yourself of how nice OO can be

Java ... no way am I going back there ... although Elasticsearch is really impressive

Emacs Lisp, maybe, I like Lisp, but I use vim most of the time

regarding editors: on a daily basis I use vim, sublime, textmate, nano, and notepad
... yes, there are computers all over the house, running all sorts of OS's, plus a bunch of cloud servers
... and I type so blazingly fast in all of them that I don't need any macro's/whatever's for repeated actions/tasks/whatevers
... just keep on truckin', as I'm <b>chicken chasin'</b> fast and no <b>Kentucky fried idiot</b>
... oh yeah, stay humble, IMHO
</pre>

<pre>
revive <a href="https://github.com/cleesmith/uni2espy" target="_blank">Uni2Espy</a>, which processes unified2 files from snort/suricata/whatever and indexes them into Elasticsearch
</pre>

</div>
<hr style="color: gray; display: block;
           margin-top: 0.5em;
           margin-bottom: 0.5em;
           margin-left: auto;
           margin-right: auto;
           border-style: solid;
           border-width: 5px;" />
<br><br>
</body>
</html>
