<!DOCTYPE html>
<html lang="en">
<head>
  <title>thoughts</title>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <meta charset="UTF-8">
  <meta name="author" content="Chris Smith">
  <meta name="description" content="thoughts, programming, ruby, python, c, java">
  <meta name="keywords" content="thoughts, programming, ruby, python, c, java">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap-theme.min.css">
  <script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
</head>

<body style="margin-top:30px; padding-top:70px;">

<nav class="navbar navbar-default navbar-fixed-top navbar-inverse">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/"><span class="glyphicon glyphicon-home" aria-hidden="true"></span> chris smith</a>
    </div>
    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="https://www.youtube.com/user/cleesmith2006/videos" target="_blank">videos</a></li>
        <li><a href="https://github.com/cleesmith?tab=repositories" target="_blank">projects</a></li>
        <li><a href="about.html">about</a></li>
      </ul>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

<div class="container">

<pre>
"Being a Python programmer, I had seen the light.
 All other languages were for some reason inferior, and as a Python programmer,
 I was the member of an elite cabal of superhuman ultranerds, smarter than
 those childish Rails/JavaScript/PHP/whatever developers that couldn’t write
 a bubble sort or comprehend even basic algorithmic complexity, but more in
 touch with reality than the grey-bearded wizards of Lisp/Haskell/whatever that
 sat in their caves/towers/whatever solving contrived, nonexistent problems for
 people that don’t exist, or those insane Erlang programmers who are content
 writing sumerian cuneiform all day long.  Of course, I knew everything, so
 I’d just do concurrency in Python, because obviously that’s a good idea, right?"
... from: <a href="http://jordanorelli.com/post/31533769172/why-i-went-from-python-to-go-and-not-nodejs" target="_blank">Why I went from Python to Go (and not node.js)</a>

Also, see: <a href="https://gist.github.com/nf/3062783" target="_blank">node.js versus go</a>
</pre>

<pre>
I can't tell if the "mini-fast with caffeine" idea works yet, but it sure makes me jittery.

Only newbies use the generators provided by Ruby on Rails. It's something you stop using after
"day one" ... as the code generated provides too much cruft/convention which you end up
changing/deleting. Everyone knows this that has spent even a few hours with Rails. But the
inexperinced see generators as a Rails feature while completely missing the point.
For me, and most developers, the best things about using Rails are:
- a big salary+benefits for very little effort ... save/use "my time" for the challenging and intersting stuff
- using Ruby for something other than cli and socket programming
- being able to quickly prototype an app, even if it's mostly CRUD, along with simple UI/UX via jQuery/Bootstrap
  - then after flushing out the features, doing user demos, etc. ... lather, rinse, repeat ...
    deciding if Java is a better choice depending on scale, and now maybe even Go for api services
    ... after all, Java and the JVM are just in another league, and comparing Java to Ruby, Python, or Go is unfair

This is just the reality of 2015.

Anyone expressing an opinion otherwise about Rails simply lacks experience developing web apps
and they should be ignored ... obviously.

Also, anyone stating as an absolute that Python is the only language to choose has definitely
gone over to the dark side. Programming languages are a bit like having brand names on hammers.
Is a Stanley really better than a Tekton ? No! It's a damn hammer, so just find yourself
a nail. An absolute opinion about Python, or any programming language, only demonstrates
a limited capacity for thought and learning ... a stagnant brain. Anyone ignoring that
almost every app requires concurrency is not paying attention and wrong headed.
</pre>

<pre>
Today I'm going to try the "mini-fast with exercise" idea. To be honest, this was probably how I
operated daily back when I worked and walked/commuted in NY and DC for over 20 years. The idea is
based on the fact that most everyone mini-fast's as they sleep during the night, unless you
wake up and raid the fridge. So you don't eat breakfast right way, instead you drink some
coffee or other caffeine laden beverage and then exercise (like a 2 mile brisk walk). Supposedly
the caffeine enhances the fat burning that your body is already prepared for and doing during
the mini-fast while you slept. Yes, even skinny people have fat and women more so than men.

FACT: the only way to lose or maintain weight is to eat less calories -- end of story.

Fancy fad diets don't work, just eat better food, avoid all starches, and eat less.
If you have to count calories, do it, after all what doesn't have a nutrition label on it.
Buy smaller plates, bowls, glasses, cups. Drink water like you live in the desert.
Use every trick you can think of, but not because you will live longer rather you will
feel better -- after all a meteor could fall on you or more likely some space debris or if
you live in the boondocks (like me) a stray bullet from a red neck in a drunken stupor.
Longevity is overrated -- do I really want to be so old that I'm totally useless, not me -- but
I really do want each and every minute to be worth living, enjoying, and feeling better
or as good as possible.

Also, exercise doesn't help that much unless you run a marthon every day, even then you could eat
a pizza plus soda plus ice cream and completely replace/exceed the calories lost during exercise.
Exercise is mostly about feeling better, but there are some beneficial effects for your body as well
as your mind -- so clear your mind by going for walk whether it's a scenic trail or just
a stroll around town breathing in those fossil fumes (what can you do?).

Just get over it -- and take back control over how you live your life. Simple, eh?
</pre>

<pre>
Just created the <a href="https://github.com/cleesmith/seotec" target="_blank">SeoTec</a> github repo.
Maybe Cellinetics or SeoHat is a better name ... wait, maybe cellinetics is too much like dyanetics (not good).
Regardless of the name, this green light's the progress I've made on using Go for api/microservices,
and probably over the weekend I will commit some code.

I'm also taking github's editor <a href="https://atom.io/" target="_blank">Atom</a> for a spin, just for some variety.
I doubt I would ever regularly use something written in Javascript/Coffeescript, well, except for web sites.
</pre>

<pre>
Did another 11,000+ steps walk (about 5 miles) early today, as it might rain soon.
Then I made a wonderful artichoke dip with parm cheese and olive oil with celery for dipping.

Whole foods are so much better than the preprocessed foods in the other hundred aisles at the supermarket.
Veggies and fruits seem to be an after thought as they only occupy a tiny space -- I guess
perishable means lower profits.
Yes, it's not just McDonalds et al that should be put out of business but supermarkets as
well -- I wonder what it would take for them to change their ways. It does not look like
consumer willpower is working. If it's available, people will eat it. Here's a thought:
what if when you pulled up to a fast food drive thru it could instantly determine your
state of health, and adjust the menu accordingly -- say your fat/lazy -- so the menu
offered instantly changes to water and various salads with zero calorie dressing and
no croutons -- and they will not sell you soda or a burger. Or maybe they charge for the
food based on your weight and not the cost/weight of the food you ordered -- health care
costs are factored in and no willpower is required.
Even better do not allow cars to drive thru, you must park and walk thru a long
curvy tunnel -- i.e. work a little for your meal. Maybe have projections on
the tunnel walls of "you" as you are now and how you could be if you ate/exercised properly.
Maybe project a pic of you crammed into a coffin -- that should dull your appetite.
</pre>

<pre>
A good/interesting weekend project for learning Go would be to code some microservice-like programs:
1. given a set of 1 or more urls gather the social media counts, concurrently of course
2. given a set of 1 or more YouTube video ids gather views/likes/dislikes (scraped from html)
3. given a set of 1 or more urls scrape some useful seo info (title, description, etc.)
4. return the results as json

Initially do these on Heroku, so they can worry about security, throttling, etc.
Maybe also try deploying to DO since I have several domains and servers already setup.

This would give me some practice with and insight into using Go for:
- api services via it's built-in web server ... muxing/handling GET/POST requests
- writing a custom logger to be used to decorate http request handlers
- doing various things via Go's concurrency
- toml instead of yaml
- deployment ... well, that's kind of a no brainer with Heroku
- reliability, speed, and performance

From playing with Go I can already see that it will be great fit for api's and microservices.
I don't really see it totally replacing existing web frameworks like Rails, NodeJS, Flask,
Django, or even PHP. But a lot of what is currently being crammed into those bloated apps
can be abstracted away by using Go to provide various services. Although, it is still very
appealing to have a single easily deployed binary file that can do it all while being so
very light on resources (memory, disk, and speed). Of course, there are many other language
choices that can provide the same result.

I am surprised by how many Go examples are available on github and youtube.
Last night, I starting watching a Russian programmer creating a
series of tutorials where he recreates a facebook/twitter-like web app. It's interesting how
he is only using what comes out-of-box with Go and no external libraries, and how far
that can take an app ... impressive. This is all interesting but to pay the bills I am
perfectly happy coding in Ruby and web-apping in Rails. It's so easy. Why stress yourself
over making money when you don't have to, I mean assuming you are a programmer, just let
the joy and security wash over you. For me, Go and the other languages I'm exploring are
just ways to widen my thought horizon ... sort of like reading poetry/philosophy or observing art/nature.
</pre>

<pre>
To clear my mind and refresh my body, I'm off to walk along the river. With little
rain recently one can see clear to the bottom. These mountains are a cool place to live.
It's a bit like being on vacation every day.
</pre>

<pre>
The bad news is that creepy/pippy stalker dude continues to read this -- well, it is public.
I guess he has nothing better to do and oddly seems drawn to me. Why? ... dear God make "it" stop.
The creepy part is the he responds to every thing I write here.
Just as a slug continues plodding along, so does his year long project -- leaving a
slimey trail of poor code behind it. Briefly I found the project interesting, but there's nothing
of value nor any originality. He only uses any comment I make to somewhat (and barely that is)
better his coding. Perhaps "unboxing" things was his true calling in life.
It's as if some weird thing blew by in the wind, caught my eye, but is now gone.
</pre>

<pre>
Wednesday, August 5, 2015 (Gregorian calendar) 3:00 AM Eastern Daylight Savings time
... somewhere in the Blue Ridge mountains of the state of Virginia in the United States of America
... bears: affirmative, red necks: affirmative, loud off-road vehicles: affirmative,
    latitude: unknown, longitude: unknown, earth's position relative to the sun: unknown

I was awakened by a dream.

It seems I quit my day job and started writing a non-fiction book.
I can't remember what the book was about, exactly, but it was decidedly not fiction.
My suspicion is that this dream is related to my feelings regarding the state of
affairs of computer science, technology, and life in general.
It seems to me that everything is stagnant.
This is made worse by some of the past becoming "new" again.
Such as wanna-be-hobbyist programmers or hardware similar to the Raspberry Pi.
It's all a bit disturbing.
By disturbing I mean it's 2015 and no one has a jet pack, or a flying car,
or fuel other than fossil, or a machine you can talk to like HAL (and that was 2001).
Hopefully a 2015+ HAL will understand phrases like "HAL, open the damn door!".

We need a revolution or an evolution or something and soon.

Back to the dream, for some reason I was drawn to Japan, or maybe it was Hong Kong, or
some place in Asia. That was my home base for writing, why?, I don't know, yet.
I do remember that I was investigating some research a friend of mine and others were doing.
In general, it was an attempt to create an organic/biological/whatever brain-like-thing, but on
a massive scale. Larger than the island of Quam, which I visited when I was in the Air Force.
Quam is about 10 miles long by 5+ miles wide descending to the ocean floor.
A part of the project was to create a new remote island in the Pacific ocean the size of Quam.
Well, not an island, exactly, but a damn big brain. I vaguely recall that salt water was
a key component, as well the earth's magnetic field. Otherwise she was tight lipped
with the details or the ultimate purpose of the project. My gut tells me it was a
new form of life, and I had misgivings about it. Maybe the earth itself is awakened.
Some believe that inanimate objects are not "dead", exactly. Who knows, but I do
recall a kind of aurora borealis out over the ocean.

Was this a vision or a just a very vivid dream?

I'm hoping it's one of those dreams that I can "resume" sometime, with or without the details.

What you have just read is all true. Truth is powerful. If the moon can tug on
your bowels just imagine what the truth is capable of doing. So for your protection
please apply lots of heavy duty aluminum foil around your cranium, or your cell phone if lacking
a cranium, otherwise you may be influenced by what you have just read.
While wearing your foil hat, don't forget to ensure you are well grounded by holding a
copper rod that's jammed into the earth, or even better bury yourself up to your waist
or deeper, then await further instructions on this frequency. Under no circumstances
should you attempt direct cranium-to-cranium communication. If either of your parents are
Neanderthal's please disregard this warning, as you are safe due to your extra cranium thickness.
By the way, congrats on learning to read, and, hey, football season is coming soon.
Evolution is a tough nut, huh?
For the rest of us Homo sapiens sapiens, forewarned is forearmed.

This message was sent and received in the following context:
Wednesday, August 5, 2015 (Gregorian calendar) 3:00 AM Eastern Daylight Savings time
... somewhere in the Blue Ridge mountains of the state of Virginia in the United States of America
... bears: affirmative, red necks: affirmative, loud off-road vehicles: affirmative,
    latitude: unknown, longitude: unknown, earth's position relative to the sun: unknown
</pre>

<pre>
It's funny how some folk actually think they are original. They don't even bother
to look around before patting themselves on the back and exclaiming "how awesome I am".
This is unforgivable nowadays given that it only takes a few seconds to do a search
of the inter-webs.
It's not original or awesome or noteworthy to:
- use http get/post to retrieve a value via some api
- scrape the html for a given web page via css/xpath
- use yield in python or streaming in a jinja template
- coding it sequentially and monolithically, perhaps their real goal is
  to make the code unapproachable and make themselves a necessary and
  overly important part of the project ... i.e. the "it's all about me" syndrome
All of that is actually more akin to following a recipe to bake a cake, while
delicious, it's not very original/awesome, given how anyone can go to a
supermarket and buy the ingredients and follow a recipe ... and have their
own cake and eat it too.

It's also funny how some, so called programmers, automatically gravitate to creating
a web app. Unable to see that what they are really trying to create is best done
as a command line program. The whole approach is wrong headed and based only on
"look at me", and not about being altruistic in the sense of creating a program
that is useful to those doing a particular task (say SEO).

For example, say you're writing a program to gather data to be used to assist a
client with SEO issues:
Why would such a program need to be a web app ?
Why would it require Google for persistence ?

Why not be flexible and allow multiple outputs such as a csv/xls file when everyone
knows most businesses rely on Excel ... whether Excel is good or bad is irrelevant,
it's just a fact that everyone uses it.

The input could be as simple as a haml file of url's and some directives.

Coding the program to be concurrent would allow it perform the data gathering in parallel(assuming 1+ cores),
so the user isn't waiting and wasting their time. After all, they most likely will repeat the process
over and over (wash, rinse, repeat) during their analysis.

It would be much simpler to use a command line program together with cron to repeat a task,
such as gathering data for trending.

As obvious as all of this is, they have overlooked the very thing that has made all
*nix's a success ... small "single purposed" command line programs whose input/output
can be chained together to accomplish cool stuff and get work done. Focusing on the
grandiose means you've missed the simple but powerful that's right in front of your face.
How can anyone who uses *nix tools like git and vim on a daily basis miss the mark so badly?
A simpler design would open a vast horizon of possibilities for such a program,
whereas shoehorning it into a web app with a huge Google dependency only
ensures it's limited and will ultimately be a failure. Simply put it's wrong headed. This is
largely due to over reaching for the grandiose ("me, me, me") while exclaiming no one
understands "me" because I'm so original and futuristic.
It's all just another bottle of snake oil, and poorly done snake oil at that
... oh look, if you peel off the label on the bottle there's another one underneath that says poison.

It's also interesting to observe that some folk can't think/work without some
resistance or opposition to rant/rave against. As if they are good/righteous and require
others who are bad/evil to inspire and motivate them. This is indicative of a flawed intellect,
and a lack of discipline to focus and think for themselves.
</pre>

<pre>
Just finished reading "The Philosopher's Stone" by Colin Wilson. It was a quick read
because of it's pace. A strange sort of science fiction, so I think I will read more
by this author, and maybe check out some of the Lovecraft references.
</pre>

<blockquote>
Python is convenient, and in many ways, a great advance over the C programming language.
However, just as teaching teenagers to drive automatic transmission is a practical
guarantee that they’ll never learn stick, advising neophytes to learn Python is creating
programmers who will never bother to learn how to code in C.

And that, I believe, is a bad thing ...
Programmers who only know Python lack a proper mental model of how computers work.
</blockquote>

<pre>
I agree with the above quote totally, and I would even throw in that just as
a teenager should learn how to raise the hood and change the oil, learning to
code should involve some exposure to assembly/machine code. Not to mention that
for smart people Python is easy to learn and therefore it's rote/boring and lacks
the ability to instill a curiosity about how computers work.
Don't we need smart people writing code/apps ?
Aren't the best people always motivated by a thirst for knowledge ?
If you are just learning to program computers start with C ... no if's/and's/but's.
Every job interview should throw some C code at a potential employee then
listen to what they have to say about it. If there's a blank look on their
face we don't hire them. We are looking for someone who gets that certain
joy from mastering a machine, which is a distinctly human pleasure.
</pre>

<pre>
Oh look there's a MIT graduate-level DS course with a focus on fault tolerance,
replication, and consistency, all taught via lab assignments in GoLang!
Just do: git clone git://g.csail.mit.edu/6.824-golabs-2014

Here's a simple example that could be used to fetch counts from various social api's
(like tweets, facebook likes, google +'s, etc.) almost simultaneously (you know, fast):
<a href="https://gist.github.com/cleesmith/303fa4c5a07fa81eb22d" target="_blank">Gist</a> of the code.

... similar code could be used to scrape a web page and all of that being done
asynchronously. If one needed to keep the user informed as to what is
happening, Go has channels built in which are perfect for sending/receiving
messages from async routines while they are working (or even for errors/timeouts).
You can kind of do this in Ruby/Python but it's not as fast or as lightweight,
because goroutines are not threads(heavy) nor processes(very heavy). Also,
why should a user in 2015 wait 5+ seconds for all this to complete when they
can usually wait less than a second ... come on it's 2015. Typically I see
the "with_goroutine" finish in 0.17 seconds compared to the 1.34 seconds doing
the get's sequentially.

Things to note:
- one can read Go code from top to bottom and understand it's intent
- Go is so simple, about 25 keywords, you can learn it in a single video:
  https://www.youtube.com/watch?v=CF9S4QZuV30
  or take the tour at http://tour.golang.org/list
  So if you're not really a coder/programmer, or you code infrequently, then
  this is good news as you don't have to spend a lot of time relearning or
  struggling to remember syntax/concepts just to scratch some itch.
- the advantages of a single, self-contained binary are real, and compilation is fast
  ... and coming from a C/C++ background, the compilation speed is a big deal
- build once for all platforms, then give a friend a binary file to run and
  they can scratch the same itch as you
- it offers the 3 simple things almost every program needs:
  - input
  - output
  - concurrency ... without the usual gotcha's and complication, heck even
                    javascript can do this
- don't like the DRY doctrine then Go is for you, which makes the code verbose but still readable
- sure, it ain't perfect, but while we wait for a future without programming
  it's just another tool in the toolbox and a means to an end
  ... granted, you can still use Python/Ruby but everyone reaches a point where both
      of those choices become a bit of a nightmare as they are slow and difficult to maintain:
      - for Ruby it's the whole install and gems issue
      - for Python it's the same as Ruby but with an extra bother of version 2 vs 3 (kind of a bad community smell there)
  ... and don't even mention Java and J2EE-land
- Go will never, nor was it intended to, replace C/C++ but it can replace Ruby, Python, Java, and the like
- Go is a perfect fit for open source projects:
  - if on github the only way your project grows is via contributors (most of whom are unknown and so are their skills), so
    and so Go levels the playing field as there are no language secrets/tricks to deal
    with when reviewing a pull request ... i.e. no one can be a smarty pants
  - tools like gofmt, golint, go vet standardize the code making reviewing less tedious
  - no need for a project owner to be a rockstar or have an ego the size of Montana
    ... you can just be a good person doing altruistic work
  - so despite the languages shortcomings, criticism, and trendiness it will probably
    continue to grow because of it's open source fitness
</pre>

<pre>
Thoughts:
- is open source really revolutionary if the hardware is closed/controlled, looking at you Intel/IBM/who_knows
- UEFI is a joke on us so hardware vendors(read that as Microsoft) can continue to collect royalties
- should we really still be using PC hardware ... doesn't seem to match what servers do
- the dominant OS's today are GNU/Linux (servers and mobile devices) and
  Microsoft Windows (all the legacy systems that aren’t mainframes)
  ... and neither has any features that help manage large-scale deployments
- is anyone(s) really capable of stepping up and improving the state of OS's
- are there any app developers who actually understand how computers work and is that the
  reason they don't know anything about how to use tooling to debug, observe, and improve their code
- things are broken, but can they be fixed ? ... alas, hope rarely meets reality
  ... this a time best described as "going through the motions"

Disclaimer: I am not the only one to have these thoughts and I can't quote any sources, that I remember, which may have influenced me.

Perhaps the only solution is to remove the hardware/software(as done by humans) from the
process. Say no to silicon or whatever metal is used nowadays. Go biological. Mostly
water, carbon, and so on ... just chemical. Just pretend it's not alive, or maybe
that's the next evolutionary step. Instead of breeding or killing the current human
species we create a shiny new replacement ... smarter and faster and thoughtful.
Probably not as easy to do as it is to say.
</pre>

<pre>
What better way to display ignorance than to write/blog about programming languages you
have never used. If your github repo's don't have any projects written in Ruby or
GoLang or Perl or whatever then can you really have an informed opinion that's
based on experience? No. All you are doing is just regurgitating things you've read from
blog/wikipedia articles. Very lame. We can all google and read for ourselves. With
the name dropping of semi-famous geeks making it even worse.
It boils down to an opinion based on only coding "toy apps" for personal use, which
is fine, but don't be preachy about it. A lot of the computer science stuff only
begins to make sense when you've worked on large apps and with other people. And
those other people all have different skill levels, so common denominators must
be found for an app to be useful/successful. By "common denominators" I mean
best practices and known patterns both of which have already proven themselves
over time. Facts are facts, so get off your little hobby horse and get a
job as a programmer with a team of at least a dozen other people and then
reassess your opinions. Not to mention the fact that if a "toy app", or niche gimmick as it were,
should take at most a weekend yet drags on for over a year then your skills are
obviously sorely lacking ... it's right there in black/white in the github repo.
And even after a year it's still as buggy as sin and what can be called toxic to programming by example.
Also, does anyone really want to use an app that has a dancing penis gif in it -- creepy.
</pre>

<pre>
As odd as it is to say, having diabetes type-2 is kind of a blessing in disguise. WTF?
By that I mean if you pay attention while trying to lessen the effects of diabetes, you
can really get to know how "your" body works. For example, I use to run marathons and
since that burns tons of calories you don't really pay attention to what you're eating.
Say those pre-marathon dinners with huge amounts of pasta/spaghetti ... tasty but not
really good for a body. When I stopped running due to a knee injury (not serious just
too painful to run) and continued with the poor eating habits, guess what, you gain
weight but worse you're whole body goes whacky. My idea of exercise was running until
you wanted to puke. Manly, right, wrong! It turns out that lesser exercises, such as
walking, really do have an effect on your body. Currently I'm walking from 6 to 8 miles
per day, and cut myself a break on Sunday's with less walking which allows for some recovery.
Who knew that using slow twitch muscles was exercise, after all we are designed to walk all day
long if our feet/back didn't get sore so it didn't seem like exercise to me. But after doing
this for only three months, my blood pressure is now within a normal range and my blood
sugar (with medication) is getting close to normal ... I feel much better and stronger.
I even learned a new programming called Go ... so my brain is working better too.
I've learned a lot about calories, carbohydrates, fats, and supermarkets. As for supermarkets,
most of the space is devoted to foods we should not eat. Like starches, which turn to sugar
almost the moment you swallow them, with nothing good in them for anyone. Sure pasta and mashed
potatoes are good, just not good for you, but hard to turn down during those holiday meals with family.
So it's all about being disciplined or feeling lousy/weak. It's all been insightful and interesting.
As always the hard part is making something the new habit over the long haul, and the horror
stories are true which is motivation enough to avoid going blind or losing a leg or having
no kidneys. Sure, as you get older things will break so diet/exercise ain't going to fix
everything, but I think feeling better is a good thing so is a good nights sleep due in
large part to the exercise. Feeling better isn't exactly happy. But what is happy? As many
have said before, happy is something you decide to be and not something you can find or
pursue (silly declaration of independence). So happy it is, and feeling better too.
</pre>

<pre>
It's funny how many so-called programmers use stackoverflow to solve problems. This is
one of the questions we use when hiring programmers. If they answer yes we don't hire
them. Imagination and problem solving are important skills every programmer should
have, and not googling for a solution. Sure, being lazy is a good thing for programmers,
but not if it means copying/pasting from stackoverflow. All that means is you don't
understand the language you're using well enough to reason about the problem you're
trying to solve. Sure there may be times when one has to research the new or unknown,
but any programmer worth their salt will not give in to the temptation to copy/paste code.

It's funny how many so-called programmers don't really understand some of the computer
science concepts that have evolved over many years. Not all of which come from lofty
university thinkers, rather they are pragmatic. For example, ask someone to explain DRY
and see that they don't really understand. Sometimes this is due to a lack of experience,
i.e. they haven't spent years working on large projects with a team of people.

Another bad sign, or code smell as they say, is any code in any language laced with comments.
Comments are a distraction to understanding the code, because the "word is not the thing" ...
just because a comment says so does not make it so. Comments are just another indication that
the programmer is struggling to express code is a readable way.
They are incapable of thinking clearly, but it's something everyone can learn to do if only
they apply themselves.
</pre>

<pre>
The good news is that creepy stalker dude is no longer following me. Perhaps getting
hammered in the head broke something. When the rest of us get hammered we're just drunk.
And to think all of that started because I said I was inspired to write some code
based on his videos. Mostly the ones about the raspberry pi and the short stack. But
his response was to make two more videos where he repeatedly used my "full" name in
a bullying fashion. I had to ask YouTube to have him remove the videos. Months go by, and
by, and then he starts to code (if you can call it that). I felt like I needed to comment
and point out that his code was poorly written (even for python), slow, and unreliable. All
of which were true, but in retrospect I should have just moved on down the trail to avoid
the creepy stalker rants/raves that happened next. Live and learn. I've done the same
thing on other open source projects and never encountered any creepiness. You just
never know until you open the can, so to speak.
</pre>

<pre>
With my kids all grown up, off on their own, and an empty house in a beautiful mountain setting,
I am finally able to enjoy myself. Not just with work related projects and research, but to
dabble with various things: drawing/painting, photography, acting/theatre, flintknapping obsidian,
collecting computers(newest is a MacPro server with 6 cores 64GB mem and a Raspberry Pi 2),
a 360 video camera(it captures everything but itself), a civil war pistol(fun/dangerous),
cat dancing(also fun/dangerous, don't ask), and yes even new programming languages.

An aside: if COBOL/Forth are still available I'm sure Go will endure ... not to mention that COBOL
is still actively used in mainframe environments. I updated a COBOL program for an old client
during Christmas vacation last year ... remembering JCL was the hard part. The occassional $250/hour
gig is nice, if you have those ancient skills ... not the least of which is editing anything by
having to use a 3270 terminal emulator. That's a bit like Neo going to meet the Source of the
matrix, but without the cool graphics and fight scenes(the only fight is editing, yawn).

Any of my projects on github, public that is, are just curiosities ... if they are
useful to someone in some way that's great, but if not that's great too.  I already derive
a sense of fulfillment/joy from my "day job", so I'm not looking to start a movement or "pied pipe"
anyone in any direction. Besides retirement is just a year away so my interests are growing
past just earning an income. Don't care about github clone counts or any social metric ... to me,
life is more than that meaningless nonsense. Whatever tickles my fancy is my only compass.
Some call this the pursuit of happiness. For me, it can be as simple as a cup of tea and a book
such as "The Mind Parasites" by Colin Wilson ... what a creepy writer, but in a good way.

Since I mentioned the Raspberry Pi it seems also worth mentioning that I've had one in a plastic
box outside in the elemments for two years now. It mostly captures pics of the neighbor's cats.
I wrote the motion detection software in Python (soon to be in Go). It's amazing that something that
cost about $80 in total has lasted that long and worked that reliably. The coolest pic was
that of a small black bear investigating the porch ... she/he looked directly into the camera, as if posing.
</pre>

<pre>
An interest was expressed today in <a href="https://github.com/cleesmith/rulespy" target="_blank">RulesPy</a> which manages rules for Snort/Suricata.
This is good opportunity to rewrite it in Go since it's currently a Python/Flask web app and it could use the upgrades/enhancements.
</pre>

<pre>
If I wanted to make Cellipede a web app there are many options available, for example:
<a href="http://beego.me/docs/intro/" target="_blank">beego</a> if one wanted to continue in the cookie cutter rut that is Python/Flask or Ruby/Rails
See <a href="https://github.com/avelino/awesome-go" target="_blank">awesome-go</a> for a curated list of Go frameworks, libraries and software.
However, I just don't see gathering social metrics and page scraping as a web app, but more of a command line
program that dumps the gathered data to a csv/xls file, google drive, or whatever.
But there's definitely concurrency as counts and scraped data are from different sources
and can be gathered in parallel ... this is so obvious as to be stupid not to do it that way,
why waste 10 seconds when the whole thing can be done in 3 seconds (or whatever the longest took).

Of course, for my day job I'm stuck with C++, Ruby/Rails, and some Python programs.
I could switch the Python programs to Go, which I will do as my employer is cool with that.
I could switch the C++ programs to Go, but there's really no compelling reason to do so ... as
they are already statically linked, easy to install, and blazingly fast.
However, because Ruby/Rails is so familiar and simple -- well, until you have to scale it -- I'm
stuck with it for the foreseeable future. But hey the pay is great plus Ruby is a thing of
beauty to read/write when the opportunity arises to get off the "rails". While python can
be written in a OOP way like ruby, that does not seem to be the common approach. It's like
python is the "Joe lunch pail" of programming languages, because those who can't think and
reason about a problem look for a package/library of which there are many. But "many" does
not equal worthy of being used. So that leaves a pythonista with just writing a tiny bit of
"glue code" (similar to PHP), and spending the rest of their time wrestling with deployment.
By deployment I mean trying to get easy_install, or pip, or C libraries to all match up and
work as expected. It's that headache that led to containers (like Docker) and Chefs and Puppets - wtf?
How about that, Docker is written in Go. Notice that at no time and in no way do I refer to
Javascript, which unfortunately is just a necessary evil on the front end of all web apps ...
so it will remain the "king of all programming languages" and the ultimate atlatl. So why
not give in to the dark side that is javascript and use node.js? A good question. Well,
fortunately, programming is like life with lots of diversity and choices. So do what you
enjoy and get down off of your soap box. I will always love ruby (cha-ching$) and appreciate
the knowledge that c/c++ has provided me, but now like all of the other languages tried
before I will give Go more than a cursory glance ... because I can afford to, I enjoy coding,
and it's a good thing to stretch one's mind (even if the underlying problems are still the same).
I don't sit around all day googling/reading blog posts and then pretend I have an informed
opinion based on "real" experience. Nor do I try every programming language that comes out the pipe.
It's been a while, but I even wrote two languages myself. I sure hope no one discovers them
or worse that someone is using them. One was like Pascal and the other was like Forth. I always
liked Forth, how can you not like a language that can create programs that alter their machine code
while it is executing ... cool and stupid at the same time ... for some reason that reminds
me of core war in 1984 and my old Super Elf (those were the days, ah, the smell of solder ... or
better said "hot molten lead").
Here's a <a href="http://www.digibarn.com/collections/systems/quest-cosmac-super-elf/index.html" target="_blank">Super Elf</a> but mine was in a wood case ... what's that guy thinking? is it a computer without the wood? wtf?
</pre>

<pre>
The concurrency offered by Go makes it a perfect choice for Cellipede:
- as many of the tasks don't need to be done sequentially
- all of the social metrics gathering can be done concurrently
- instead of waiting 5-15 seconds for all of the api's or scrape's to respond, they
  can be done concurrently which means the total time is equal to the longest task
  and not all of them added together ... i.e. way faster

Of course, the greatest advantage of using Go is compiling a single binary file for a target system.
No more dependency hell ... just scp/rsync/whatever the file to the target and run it.

And compiling for any/all target systems, including ARM (Raspberry Pi, etc.), is simple using
the Go installed by Homebrew ... i.e. do everything on a Mac, just once, but deploy anywhere -- way cool.

If all of us are putting all of our eggs in Google's basket, g+/gmail/calendar/docs/maps/etc, what
better programming language choice than the one funded/used internally by Google ... Go_ogle it is.

Of course, absolutely none of the above is new (see Hoare 1978) ... think C/C++ ... but Go is
just a better and simpler packaging of what's been learned over the years.

There's no one solution, well, until the day arrives when computers can solve problems all
by themselves (without humans). Sure, it will happen, but by that time they will be
called "focused thinkers"(FTs) or some such and the idea of "computing" will be long dead.
Why the term "focused thinkers"(FTs)?  Because humans suck at focusing, we're easily distracted,
whereas FTs' will have laser focus on the task at hand (so to speak).
We will be partners, FTs and humans, and hopefully the FTs will not smash us the way we probably
did the Neanderthals. Imagine two football teams made up of Neanderthals, e.g. the Unibrows vs Rockheads,
on surround sound TV and all of the concussions/injuries ... I'm sure the Romans would have filled the
coliseum with them.  My guess is that we used our atlatl's to kill them or bred them out ... brain power rules.
Go is so simple even a Neanderthal can do it, or could if they were still around.
Go is just another in a long list of atlatls, i.e. a tool we use to help us with stuff.
What we really need is the next evolutionary step above tooling, such as a focused thinker and
who knows what form that may take ... it does not have to be a machine. Perhaps we change or evolve
into focused thinkers, and inevitably smash the current us, of course.

This universe is a funny ole dog.

... obliquely related joke:
How is a Harley Davidson like an old dog?
They both like to ride in the back of pickup trucks.

What is the difference between a Harley Davidson and an old dog?
The dog can get in the back of the pickup by itself.

I don't own or know how to ride a motocycle or know anyone who does, so why does this joke stick in my head?
Further evidence of how unfocused humans can be ... we've had our time in the sun and it's time to evolve, yet again.
</pre>

<pre>
just discovered <a href="https://golang.org/" target="_blank">Go</a> (GoLang):
- it's fast when compiling and the result is fast at execution time
- it's cool, coz "go build" creates a statically linked program
- a "statically linked program" is cool coz it can just be copied around without an install or dependencies ...
  it just needs to be a binary file that's built for that operating system (linux, mac, windows)
- a program can be compiled on a Mac for all operating systems ... i.e. cross compiling
- installation of a program becomes just copying the binary file to the target system
- a small <a href="http://beego.me/" target="_blank">Beego</a> (like flask/rails) web app is about 20MB binary file, that's small
- there's no installing an interpreter (Python or Ruby), or packages/dependencies (pip or gems) ...
  the only real dependency is the target system
- the downside is that the Go language is not as eloquent as Ruby, but it's faster/smaller and without the
  usual difficult and error prone installation process

Python is great for beginners and playing around.

Ruby is great for learning object oriented programming, teams, and cookie cutter web apps with Rails.

Go is the way forward ... with:
  - great docs
  - everything that's provided by Ruby/Python but with a different syntax
  - contains a fully functional web server, but can also be proxied via nginx (which is much faster for static assets)
  - multi-core support baked in
  - concurrency built-in
  - high performance is in large part due to the static compilation of the statically-typed code (not quite as fast as C, but close)
  - no install on target system due to static linking, just copy binary file to target then "./someprogram"
</pre>

<pre>
an open source alternative to <a href="https://slack.com" target="_blank">Slack</a>:
<a href="http://www.mattermost.org/" target="_blank">Mattermost</a> at <a href="https://github.com/mattermost/platform" target="_blank">github</a>
- Mattermost is coded in Go (a better C?) and available as a Docker image
- Slack is coded in PHP (yuck!), MySQL (yuck!), and uses SOLR (yuck!) for indexing/searching
- Mattermost has fewer features than Slack
- Mattermost can be hosted locally if security matters or if you don't want to pay a service fee
- there are other Slack-like projects, but Mattermost is not just another pile of open source code as they are also building a community
- Slack is better if you don't have enterprise/security concerns and don't mind paying for the service
</pre>

<pre>
new software:
<a href="https://github.com/cleesmith/cellipede_ruby" target="_blank">cellipede_ruby</a> which is a search engine optimization, SEO, command line tool for data gathering that creates Excel spreadsheets
</pre>

<pre>
the beauty of Ruby and what few people understand ... simplified:
- <b>1.class</b> means <b>1</b> is an <b>object</b> whose <b>class</b> is Fixnum
- <b>Fixnum.instance_methods(false)</b> reveals this object to have these methods [:to_s, :+, :-, :==, etc], so
- <b>1.to_s</b> is really 1.send(:to_s) and <b>1 + 1</b> is really 1.send(:+, 1)
- yes, <b>send</b> is just passing a <b>message</b> to an <b>object</b>
- of course, I don't need to know about <em>sending messages to objects</em> just to do <b>1 + 1</b>

Ruby is an absolute beauty and why I say it's <b>manna from heaven</b>, ok, Japan actually.
Of course, it may be more beautiful to have a language like Smalltalk with only 6 keywords and no conditionals ... true OO
</pre>

<pre>
always apply these ideas from Sandi Metz:
 <b>be Smalltalk infected</b>
 <b>be Condition averse</b> ... when possible avoid if/else/case/unless ... keep the <em>happy path</em> visible and readable
 <b>be Message centric</b>
    - don't own the behavoir of an object
    - null object pattern
    - composition ... beware of always using inheritance, it's not for sharing behavoir
    - independency injection for behavior
 <b>be Abstraction seeking</b>
* see: <a href="https://www.youtube.com/watch?v=OMPfEXIlTVE" target="_blank">Sandi Metz</a> and her <a href="http://www.amazon.com/Practical-Object-Oriented-Design-Ruby-Addison-Wesley-ebook/dp/B0096BYG7C/ref=tmm_kin_title_0?_encoding=UTF8&sr=8-1&qid=1434722417" target="_blank">book</a> is great too
For the most part, my projects accomplish each of the <b>be</b>'s above.
</pre>

<pre>
If you have a project that you consider to be <b>intellectual property</b> ... that's great, you're brilliant,
but keep it to yourself, try a private repo, until you're ready to <b>gift your little wonder</b> to the world

But open source is not <b>intellectual property</b>, and best explained by Remy Sharp:
"<em>
 Welcome. Welcome to this code I wrote.
 Help yourself to bits you like or need.
 Help make it better for others.
 Help make it yours.
 Help make me better with your suggestions, changes or discussion.
 Use the code in any way you want, in ways I never thought of.
 And if the projects I created lives on without me, then open source has worked.
"</em>
If you don't understand the above then you just don't understand github or open source software.
</pre>

<pre>
learn Clojure and Elixir

return to Smalltalk more often

Rails, given the <b>monkey-patched mess</b> it's become, will be the ruin of Ruby
... bummer, as I used Ruby before Rails came along, and, often, it will put a <b>smile on your face</b>

Python ... well, why, if you have Ruby? ... well, ok, maybe for nltk, pandas, scipy, scikit-learn, matplotlib, and numpy.
Sometimes you may want to <b>wax nostalgic</b> and relive the days of gigantic loops, with lots of sideways pyramid-style indented code,
and if-else's the size of Montana (you know, big) ... just to remind yourself of how nice OO can be

Java ... no way am I going back there ... although Elasticsearch is really impressive

Emacs Lisp, maybe, I like Lisp, but I use vim most of the time

regarding editors: on a daily basis I use vim, sublime, textmate, nano, and notepad
... yes, there are computers all over the house, running all sorts of OS's, plus a bunch of cloud servers
... and I type so blazingly fast in all of them that I don't need any macro's/whatever's for repeated actions/tasks/whatevers
... just keep on truckin', as I'm <b>chicken chasin'</b> fast and no <b>Kentucky fried idiot</b>
... oh yeah, stay humble, IMHO
</pre>

<pre>
revive <a href="https://github.com/cleesmith/uni2espy" target="_blank">Uni2Espy</a>, which processes unified2 files from snort/suricata/whatever and indexes them into Elasticsearch
</pre>

</div>
<hr style="color: gray; display: block;
           margin-top: 0.5em;
           margin-bottom: 0.5em;
           margin-left: auto;
           margin-right: auto;
           border-style: solid;
           border-width: 5px;" />
<br><br>
</body>
</html>
